#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <ctype.h>
#include <inttypes.h>
#include <cassert>
#include <cstdint>

//#define PRINT_TABLE_SATS

#if defined(_MSC_VER)
#define ALWAYS_INLINE  __forceinline
#elif (defined(__GNUC__) || defined(__clang__))
#define ALWAYS_INLINE inline __attribute__((always_inline))
#else
#define ALWAYS_INLINE inline
#endif

#ifndef _WIN32
#define _aligned_malloc(x,y) memalign(y,x)
#define _aligned_free(x) free(x)
#endif

// Error handler: print message if any, and exit
void quit(const char* message = 0) {
  if (message) printf("%s\n", message);
  exit(1);
}

#define ALIGNMENT_BOUNDARY 256
void check_malloc_result(void* ptr) {
  if (ptr == NULL) {
    fprintf(stderr, "Failed to allocate memory.\n");
    exit(1);
  }
#ifndef NDEBUG
  if (((size_t)ptr & 0xff) != 0) {
    fprintf(stderr, "Memory in unaligned.\n");
    exit(1);
  }
#endif
}

#include <malloc.h>
void* aligned_malloc(size_t size) {
  void* ptr = _aligned_malloc(size, ALIGNMENT_BOUNDARY);
  check_malloc_result(ptr);
  return ptr;
}

// Create an array p of n elements of type T
template <class T> void alloc(T*& p, int n) {
  p = (T*)aligned_malloc(n * sizeof(T));
  memset(p, 0, n * sizeof(T));
}


///////////////////////////// Squash //////////////////////////////

static short squash_t[4096];

// return p = 1/(1 + exp(-d)), d scaled by 8 bits, p scaled by 12 bits
int calculate_squash(int d) {
  static const int t[33]={
    1,2,3,6,10,16,27,45,73,120,194,310,488,747,1101,
    1546,2047,2549,2994,3348,3607,3785,3901,3975,4022,
    4050,4068,4079,4085,4089,4092,4093,4094};
  if (d>2047) return 4095;
  if (d<-2047) return 0;
  int w=d&127;
  d=(d>>7)+16;
  return (t[d]*(128-w)+t[(d+1)]*w+64) >> 7;
}

int squash(int d) {
  assert(d >= -2047 && d <= 2047);
  return squash_t[d + 2048];
}


//////////////////////// Hash functions //////////////////////////
//
// All hash functions are constructed using multiplicative hashes
// - We usually hash small values
// - Multiplicative hashes promote entropy to the higher bits
// - When combining ( H(x) + H(y) ) entropy is still in higher bits
// - After combining they must be finalized by taking the higher
//   bits only to reduce the range to the desired hash table size

// Multipliers
// - They don't need to be prime, just large odd numbers
// - It's advantageous to have a multiplier such as m-1 is divisible by 4
//   See also: https://en.wikipedia.org/wiki/Linear_congruential_generator
// - It's advantageous when the multiplier is based on an irrational number to guarantee good (long) periodic behaviour
// - The golden ratio is usually preferred as a multiplier (PHI64) as it is the most irrational number


// Golden ratio of 2^64
#define PHI64   UINT64_C(0x9E3779B97F4A7C15) // 11400714819323198485
// Another magic multiplier
#define MUL64_1 UINT64_C(0x993DDEFFB1462949)

/**
  * Finalizer (range reduction).
  * Keep the necessary number of bits after performing a
  * (combination of) multiplicative hash(es).
  * @param hash
  * @param hashBits
  * @return
  */
  
  static ALWAYS_INLINE
    uint32_t finalize64(const uint64_t hash, const int hashBits) {
    assert(hashBits >= 0 && hashBits <= 32); // just a reasonable upper limit
    return static_cast<uint32_t>(hash >> (64 - hashBits));
  }

 /**
  * Get the next 8 or 16 bits following "hashBits" for checksum
  * @param hash
  * @param hashBits
  * @return
  */
  static ALWAYS_INLINE
    uint8_t checksum8(const uint64_t hash, const int hashBits) {
    constexpr int checksumBits = 8;
    return static_cast<uint8_t>(hash >> (64 - hashBits - checksumBits)) & ((1 << checksumBits) - 1);
  }

  static ALWAYS_INLINE
    uint16_t checksum16(const uint64_t hash, const int hashBits) {
    constexpr int checksumBits = 16;
    return static_cast<uint16_t>(hash >> (64 - hashBits - checksumBits)) & ((1 << checksumBits) - 1);
  }

  //
  // value hashing
  //
  // - Hash 1-2 64-bit (usually small) integers
  //

  static ALWAYS_INLINE
    uint64_t hash(const uint64_t x0) {
    return (x0 + 1) * PHI64;
  }

  static ALWAYS_INLINE
    uint64_t hash(const uint64_t x0, const uint64_t x1) {
    return (x0 + 1) * PHI64 + (x1 + 1) * MUL64_1;
  }

/**
  * Call this function repeatedly for string hashing, or to combine a hash value and a (non-hash) value, or two hash values.
  * @param seed
  * @param x
  * @return
  */
  static ALWAYS_INLINE
    uint64_t combine64(const uint64_t seed, const uint64_t x) {
    return hash(seed + x);
  }

  static const uint32_t _bits = 30;
  static const uint32_t _shift = 12;
  static const uint32_t _learn_rate = 10; //6..11
  static const uint32_t _middle = (1u << (_shift - 1)) << (_bits - _shift);
  ALWAYS_INLINE void fastbit_init(uint32_t* p) {
    p[0] = _middle;
  }
  ALWAYS_INLINE void fastbit_update(uint32_t* p, uint32_t bit) {
    p[0] += ((static_cast<int>(bit) << _bits) - static_cast<int>(p[0])) >> _learn_rate;
  }
  ALWAYS_INLINE void fastbit_setP(uint32_t* p, uint32_t new_p) {
    p[0] = new_p << (_bits - _shift);
  }
  ALWAYS_INLINE uint32_t fastbit_getP(uint32_t* p) {
    return p[0] >> (_bits - _shift);
  }

#ifdef PRINT_TABLE_SATS
  static uint64_t statecounter0[256] = {};
  static uint64_t statecounter1[256] = {};
#endif

  static uint8_t mapc0[256];

  // initial values optimized for gdcc2023 task7
  static constexpr short p_to_stretched[4096] = {
    -2047,-1798,-1681,-1605,-1548,-1502,-1464,-1432,-1403,-1378,-1355,-1334,-1315,-1298,-1281,-1266,-1252,-1239,-1226,-1214,-1202,-1192,-1181,-1171,-1162,-1153,-1144,-1135,-1127,-1119,-1112,-1104,-1097,-1090,-1083,-1077,-1070,-1064,-1058,-1052,-1047,-1041,-1036,-1030,-1025,-1020,-1015,-1010,-1005,-1001,-996,-991,-987,-983,-978,-974,-970,-966,-962,-958,-954,-951,-947,-943,-940,-936,-932,-929,-926,-922,-919,-916,-913,-909,-906,-903,-900,-897,-894,-891,-888,-885,-883,-880,-877,-874,-872,-869,-866,-864,-861,-859,-856,-854,-851,-849,-846,-844,-841,-839,-837,-834,-832,-830,-828,-825,-823,-821,-819,-817,-815,-812,-810,-808,-806,-804,-802,-800,-798,-796,-794,-792,-790,-789,-787,-785,-783,-781,-779,-777,-776,-774,-772,-770,-769,-767,-765,-763,-762,-760,-758,-757,-755,-753,-752,-750,-748,-747,-745,-744,-742,-741,-739,-737,-736,-734,-733,-731,-730,-728,-727,-725,-724,-723,-721,-720,-718,-717,-715,-714,-713,-711,-710,-708,-707,-706,-704,-703,-702,-700,-699,-698,-696,-695,-694,-693,-691,-690,-689,-688,-686,-685,-684,-683,-681,-680,-679,-678,-676,-675,-674,-673,-672,-670,-669,-668,-667,-666,-665,-664,-662,-661,-660,-659,-658,-657,-656,-655,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-597,-596,-595,-594,-593,-592,-591,-590,-590,-589,-588,-587,-586,-585,-584,-584,-583,-582,-581,-580,-579,-579,-578,-577,-576,-575,-575,-574,-573,-572,-571,-571,-570,-569,-568,-567,-567,-566,-565,-564,-563,-563,-562,-561,-560,-560,-559,-558,-557,-557,-556,-555,-554,-554,-553,-552,-551,-551,-550,-549,-548,-548,-547,-546,-545,-545,-544,-543,-543,-542,-541,-540,-540,-539,-538,-538,-537,-536,-535,-535,-534,-533,-533,-532,-531,-531,-530,-529,-528,-528,-527,-526,-526,-525,-524,-524,-523,-522,-522,-521,-520,-520,-519,-518,-518,-517,-516,-516,-515,-514,-514,-513,-513,-512,-511,-511,-510,-509,-509,-508,-507,-507,-506,-506,-505,-504,-504,-503,-502,-502,-501,-501,-500,-499,-499,-498,-497,-497,-496,-496,-495,-494,-494,-493,-493,-492,-491,-491,-490,-490,-489,-488,-488,-487,-487,-486,-485,-485,-484,-484,-483,-483,-482,-481,-481,-480,-480,-479,-478,-478,-477,-477,-476,-476,-475,-474,-474,-473,-473,-472,-472,-471,-471,-470,-469,-469,-468,-468,-467,-467,-466,-466,-465,-464,-464,-463,-463,-462,-462,-461,-461,-460,-460,-459,-459,-458,-457,-457,-456,-456,-455,-455,-454,-454,-453,-453,-452,-452,-451,-451,-450,-450,-449,-449,-448,-447,-447,-446,-446,-445,-445,-444,-444,-443,-443,-442,-442,-441,-441,-440,-440,-439,-439,-438,-438,-437,-437,-436,-436,-435,-435,-434,-434,-433,-433,-432,-432,-431,-431,-430,-430,-429,-429,-428,-428,-428,-427,-427,-426,-426,-425,-425,-424,-424,-423,-423,-422,-422,-421,-421,-420,-420,-419,-419,-418,-418,-418,-417,-417,-416,-416,-415,-415,-414,-414,-413,-413,-412,-412,-411,-411,-411,-410,-410,-409,-409,-408,-408,-407,-407,-406,-406,-406,-405,-405,-404,-404,-403,-403,-402,-402,-402,-401,-401,-400,-400,-399,-399,-398,-398,-398,-397,-397,-396,-396,-395,-395,-394,-394,-394,-393,-393,-392,-392,-391,-391,-391,-390,-390,-389,-389,-388,-388,-388,-387,-387,-386,-386,-385,-385,-385,-384,-384,-383,-383,-383,-382,-382,-381,-381,-380,-380,-380,-379,-379,-378,-378,-378,-377,-377,-376,-376,-375,-375,-375,-374,-374,-373,-373,-373,-372,-372,-371,-371,-371,-370,-370,-369,-369,-369,-368,-368,-367,-367,-367,-366,-366,-365,-365,-365,-364,-364,-363,-363,-363,-362,-362,-361,-361,-361,-360,-360,-359,-359,-359,-358,-358,-357,-357,-357,-356,-356,-355,-355,-355,-354,-354,-354,-353,-353,-352,-352,-352,-351,-351,-350,-350,-350,-349,-349,-349,-348,-348,-347,-347,-347,-346,-346,-346,-345,-345,-344,-344,-344,-343,-343,-343,-342,-342,-341,-341,-341,-340,-340,-340,-339,-339,-338,-338,-338,-337,-337,-337,-336,-336,-336,-335,-335,-334,-334,-334,-333,-333,-333,-332,-332,-332,-331,-331,-330,-330,-330,-329,-329,-329,-328,-328,-328,-327,-327,-326,-326,-326,-325,-325,-325,-324,-324,-324,-323,-323,-323,-322,-322,-322,-321,-321,-320,-320,-320,-319,-319,-319,-318,-318,-318,-317,-317,-317,-316,-316,-316,-315,-315,-315,-314,-314,-313,-313,-313,-312,-312,-312,-311,-311,-311,-310,-310,-310,-309,-309,-309,-308,-308,-308,-307,-307,-307,-306,-306,-306,-305,-305,-305,-304,-304,-304,-303,-303,-303,-302,-302,-302,-301,-301,-301,-300,-300,-300,-299,-299,-299,-298,-298,-298,-297,-297,-297,-296,-296,-296,-295,-295,-295,-294,-294,-294,-293,-293,-293,-292,-292,-292,-291,-291,-291,-290,-290,-290,-289,-289,-289,-288,-288,-288,-287,-287,-287,-286,-286,-286,-286,-285,-285,-285,-284,-284,-284,-283,-283,-283,-282,-282,-282,-281,-281,-281,-280,-280,-280,-279,-279,-279,-278,-278,-278,-278,-277,-277,-277,-276,-276,-276,-275,-275,-275,-274,-274,-274,-273,-273,-273,-273,-272,-272,-272,-271,-271,-271,-270,-270,-270,-269,-269,-269,-268,-268,-268,-268,-267,-267,-267,-266,-266,-266,-265,-265,-265,-264,-264,-264,-264,-263,-263,-263,-262,-262,-262,-261,-261,-261,-261,-260,-260,-260,-259,-259,-259,-258,-258,-258,-258,-257,-257,-257,-256,-256,-256,-255,-255,-255,-255,-254,-254,-254,-253,-253,-253,-252,-252,-252,-252,-251,-251,-251,-250,-250,-250,-249,-249,-249,-249,-248,-248,-248,-247,-247,-247,-247,-246,-246,-246,-245,-245,-245,-244,-244,-244,-244,-243,-243,-243,-242,-242,-242,-242,-241,-241,-241,-240,-240,-240,-240,-239,-239,-239,-238,-238,-238,-237,-237,-237,-237,-236,-236,-236,-235,-235,-235,-235,-234,-234,-234,-233,-233,-233,-233,-232,-232,-232,-231,-231,-231,-231,-230,-230,-230,-229,-229,-229,-229,-228,-228,-228,-228,-227,-227,-227,-226,-226,-226,-226,-225,-225,-225,-224,-224,-224,-224,-223,-223,-223,-222,-222,-222,-222,-221,-221,-221,-220,-220,-220,-220,-219,-219,-219,-219,-218,-218,-218,-217,-217,-217,-217,-216,-216,-216,-216,-215,-215,-215,-214,-214,-214,-214,-213,-213,-213,-212,-212,-212,-212,-211,-211,-211,-211,-210,-210,-210,-209,-209,-209,-209,-208,-208,-208,-208,-207,-207,-207,-206,-206,-206,-206,-205,-205,-205,-205,-204,-204,-204,-204,-203,-203,-203,-202,-202,-202,-202,-201,-201,-201,-201,-200,-200,-200,-199,-199,-199,-199,-198,-198,-198,-198,-197,-197,-197,-197,-196,-196,-196,-195,-195,-195,-195,-194,-194,-194,-194,-193,-193,-193,-193,-192,-192,-192,-192,-191,-191,-191,-190,-190,-190,-190,-189,-189,-189,-189,-188,-188,-188,-188,-187,-187,-187,-187,-186,-186,-186,-185,-185,-185,-185,-184,-184,-184,-184,-183,-183,-183,-183,-182,-182,-182,-182,-181,-181,-181,-181,-180,-180,-180,-180,-179,-179,-179,-178,-178,-178,-178,-177,-177,-177,-177,-176,-176,-176,-176,-175,-175,-175,-175,-174,-174,-174,-174,-173,-173,-173,-173,-172,-172,-172,-172,-171,-171,-171,-171,-170,-170,-170,-170,-169,-169,-169,-169,-168,-168,-168,-168,-167,-167,-167,-166,-166,-166,-166,-165,-165,-165,-165,-164,-164,-164,-164,-163,-163,-163,-163,-162,-162,-162,-162,-161,-161,-161,-161,-160,-160,-160,-160,-159,-159,-159,-159,-158,-158,-158,-158,-157,-157,-157,-157,-156,-156,-156,-156,-155,-155,-155,-155,-154,-154,-154,-154,-153,-153,-153,-153,-152,-152,-152,-152,-151,-151,-151,-151,-150,-150,-150,-150,-150,-149,-149,-149,-149,-148,-148,-148,-148,-147,-147,-147,-147,-146,-146,-146,-146,-145,-145,-145,-145,-144,-144,-144,-144,-143,-143,-143,-143,-142,-142,-142,-142,-141,-141,-141,-141,-140,-140,-140,-140,-139,-139,-139,-139,-138,-138,-138,-138,-138,-137,-137,-137,-137,-136,-136,-136,-136,-135,-135,-135,-135,-134,-134,-134,-134,-133,-133,-133,-133,-132,-132,-132,-132,-131,-131,-131,-131,-130,-130,-130,-130,-130,-129,-129,-129,-129,-128,-128,-128,-128,-127,-127,-127,-127,-126,-126,-126,-126,-125,-125,-125,-125,-125,-124,-124,-124,-124,-123,-123,-123,-123,-122,-122,-122,-122,-121,-121,-121,-121,-120,-120,-120,-120,-119,-119,-119,-119,-119,-118,-118,-118,-118,-117,-117,-117,-117,-116,-116,-116,-116,-115,-115,-115,-115,-115,-114,-114,-114,-114,-113,-113,-113,-113,-112,-112,-112,-112,-111,-111,-111,-111,-111,-110,-110,-110,-110,-109,-109,-109,-109,-108,-108,-108,-108,-107,-107,-107,-107,-107,-106,-106,-106,-106,-105,-105,-105,-105,-104,-104,-104,-104,-103,-103,-103,-103,-103,-102,-102,-102,-102,-101,-101,-101,-101,-100,-100,-100,-100,-100,-99,-99,-99,-99,-98,-98,-98,-98,-97,-97,-97,-97,-96,-96,-96,-96,-96,-95,-95,-95,-95,-94,-94,-94,-94,-93,-93,-93,-93,-93,-92,-92,-92,-92,-91,-91,-91,-91,-90,-90,-90,-90,-90,-89,-89,-89,-89,-88,-88,-88,-88,-87,-87,-87,-87,-87,-86,-86,-86,-86,-85,-85,-85,-85,-84,-84,-84,-84,-84,-83,-83,-83,-83,-82,-82,-82,-82,-82,-81,-81,-81,-81,-80,-80,-80,-80,-79,-79,-79,-79,-79,-78,-78,-78,-78,-77,-77,-77,-77,-76,-76,-76,-76,-76,-75,-75,-75,-75,-74,-74,-74,-74,-74,-73,-73,-73,-73,-72,-72,-72,-72,-71,-71,-71,-71,-71,-70,-70,-70,-70,-69,-69,-69,-69,-69,-68,-68,-68,-68,-67,-67,-67,-67,-66,-66,-66,-66,-66,-65,-65,-65,-65,-64,-64,-64,-64,-64,-63,-63,-63,-63,-62,-62,-62,-62,-61,-61,-61,-61,-61,-60,-60,-60,-60,-59,-59,-59,-59,-59,-58,-58,-58,-58,-57,-57,-57,-57,-57,-56,-56,-56,-56,-55,-55,-55,-55,-55,-54,-54,-54,-54,-53,-53,-53,-53,-52,-52,-52,-52,-52,-51,-51,-51,-51,-50,-50,-50,-50,-50,-49,-49,-49,-49,-48,-48,-48,-48,-48,-47,-47,-47,-47,-46,-46,-46,-46,-46,-45,-45,-45,-45,-44,-44,-44,-44,-44,-43,-43,-43,-43,-42,-42,-42,-42,-41,-41,-41,-41,-41,-40,-40,-40,-40,-39,-39,-39,-39,-39,-38,-38,-38,-38,-37,-37,-37,-37,-37,-36,-36,-36,-36,-35,-35,-35,-35,-35,-34,-34,-34,-34,-33,-33,-33,-33,-33,-32,-32,-32,-32,-31,-31,-31,-31,-31,-30,-30,-30,-30,-29,-29,-29,-29,-29,-28,-28,-28,-28,-27,-27,-27,-27,-27,-26,-26,-26,-26,-25,-25,-25,-25,-25,-24,-24,-24,-24,-23,-23,-23,-23,-23,-22,-22,-22,-22,-21,-21,-21,-21,-21,-20,-20,-20,-20,-19,-19,-19,-19,-19,-18,-18,-18,-18,-17,-17,-17,-17,-17,-16,-16,-16,-16,-15,-15,-15,-15,-15,-14,-14,-14,-14,-13,-13,-13,-13,-13,-12,-12,-12,-12,-11,-11,-11,-11,-11,-10,-10,-10,-10,-9,-9,-9,-9,-9,-8,-8,-8,-8,-7,-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-3,-3,-3,-3,-3,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,1,1,1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,11,11,11,11,11,12,12,12,12,13,13,13,13,13,14,14,14,14,15,15,15,15,15,16,16,16,16,17,17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,20,20,21,21,21,21,21,22,22,22,22,23,23,23,23,23,24,24,24,24,25,25,25,25,25,26,26,26,26,27,27,27,27,27,28,28,28,28,29,29,29,29,29,30,30,30,30,31,31,31,31,31,32,32,32,32,33,33,33,33,33,34,34,34,34,35,35,35,35,35,36,36,36,36,37,37,37,37,37,38,38,38,38,39,39,39,39,39,40,40,40,40,41,41,41,41,41,42,42,42,42,43,43,43,43,44,44,44,44,44,45,45,45,45,46,46,46,46,46,47,47,47,47,48,48,48,48,48,49,49,49,49,50,50,50,50,50,51,51,51,51,52,52,52,52,52,53,53,53,53,54,54,54,54,55,55,55,55,55,56,56,56,56,57,57,57,57,57,58,58,58,58,59,59,59,59,59,60,60,60,60,61,61,61,61,61,62,62,62,62,63,63,63,63,64,64,64,64,64,65,65,65,65,66,66,66,66,66,67,67,67,67,68,68,68,68,69,69,69,69,69,70,70,70,70,71,71,71,71,71,72,72,72,72,73,73,73,73,74,74,74,74,74,75,75,75,75,76,76,76,76,76,77,77,77,77,78,78,78,78,79,79,79,79,79,80,80,80,80,81,81,81,81,82,82,82,82,82,83,83,83,83,84,84,84,84,84,85,85,85,85,86,86,86,86,87,87,87,87,87,88,88,88,88,89,89,89,89,90,90,90,90,90,91,91,91,91,92,92,92,92,93,93,93,93,93,94,94,94,94,95,95,95,95,96,96,96,96,96,97,97,97,97,98,98,98,98,99,99,99,99,100,100,100,100,100,101,101,101,101,102,102,102,102,103,103,103,103,103,104,104,104,104,105,105,105,105,106,106,106,106,107,107,107,107,107,108,108,108,108,109,109,109,109,110,110,110,110,111,111,111,111,111,112,112,112,112,113,113,113,113,114,114,114,114,115,115,115,115,115,116,116,116,116,117,117,117,117,118,118,118,118,119,119,119,119,119,120,120,120,120,121,121,121,121,122,122,122,122,123,123,123,123,124,124,124,124,125,125,125,125,125,126,126,126,126,127,127,127,127,128,128,128,128,129,129,129,129,130,130,130,130,130,131,131,131,131,132,132,132,132,133,133,133,133,134,134,134,134,135,135,135,135,136,136,136,136,137,137,137,137,138,138,138,138,138,139,139,139,139,140,140,140,140,141,141,141,141,142,142,142,142,143,143,143,143,144,144,144,144,145,145,145,145,146,146,146,146,147,147,147,147,148,148,148,148,149,149,149,149,150,150,150,150,150,151,151,151,151,152,152,152,152,153,153,153,153,154,154,154,154,155,155,155,155,156,156,156,156,157,157,157,157,158,158,158,158,159,159,159,159,160,160,160,160,161,161,161,161,162,162,162,162,163,163,163,163,164,164,164,164,165,165,165,165,166,166,166,166,167,167,167,168,168,168,168,169,169,169,169,170,170,170,170,171,171,171,171,172,172,172,172,173,173,173,173,174,174,174,174,175,175,175,175,176,176,176,176,177,177,177,177,178,178,178,178,179,179,179,180,180,180,180,181,181,181,181,182,182,182,182,183,183,183,183,184,184,184,184,185,185,185,185,186,186,186,187,187,187,187,188,188,188,188,189,189,189,189,190,190,190,190,191,191,191,192,192,192,192,193,193,193,193,194,194,194,194,195,195,195,195,196,196,196,197,197,197,197,198,198,198,198,199,199,199,199,200,200,200,201,201,201,201,202,202,202,202,203,203,203,204,204,204,204,205,205,205,205,206,206,206,206,207,207,207,208,208,208,208,209,209,209,209,210,210,210,211,211,211,211,212,212,212,212,213,213,213,214,214,214,214,215,215,215,216,216,216,216,217,217,217,217,218,218,218,219,219,219,219,220,220,220,220,221,221,221,222,222,222,222,223,223,223,224,224,224,224,225,225,225,226,226,226,226,227,227,227,228,228,228,228,229,229,229,229,230,230,230,231,231,231,231,232,232,232,233,233,233,233,234,234,234,235,235,235,235,236,236,236,237,237,237,237,238,238,238,239,239,239,240,240,240,240,241,241,241,242,242,242,242,243,243,243,244,244,244,244,245,245,245,246,246,246,247,247,247,247,248,248,248,249,249,249,249,250,250,250,251,251,251,252,252,252,252,253,253,253,254,254,254,255,255,255,255,256,256,256,257,257,257,258,258,258,258,259,259,259,260,260,260,261,261,261,261,262,262,262,263,263,263,264,264,264,264,265,265,265,266,266,266,267,267,267,268,268,268,268,269,269,269,270,270,270,271,271,271,272,272,272,273,273,273,273,274,274,274,275,275,275,276,276,276,277,277,277,278,278,278,278,279,279,279,280,280,280,281,281,281,282,282,282,283,283,283,284,284,284,285,285,285,286,286,286,286,287,287,287,288,288,288,289,289,289,290,290,290,291,291,291,292,292,292,293,293,293,294,294,294,295,295,295,296,296,296,297,297,297,298,298,298,299,299,299,300,300,300,301,301,301,302,302,302,303,303,303,304,304,304,305,305,305,306,306,306,307,307,307,308,308,308,309,309,309,310,310,310,311,311,311,312,312,312,313,313,313,314,314,315,315,315,316,316,316,317,317,317,318,318,318,319,319,319,320,320,320,321,321,322,322,322,323,323,323,324,324,324,325,325,325,326,326,326,327,327,328,328,328,329,329,329,330,330,330,331,331,332,332,332,333,333,333,334,334,334,335,335,336,336,336,337,337,337,338,338,338,339,339,340,340,340,341,341,341,342,342,343,343,343,344,344,344,345,345,346,346,346,347,347,347,348,348,349,349,349,350,350,350,351,351,352,352,352,353,353,354,354,354,355,355,355,356,356,357,357,357,358,358,359,359,359,360,360,361,361,361,362,362,363,363,363,364,364,365,365,365,366,366,367,367,367,368,368,369,369,369,370,370,371,371,371,372,372,373,373,373,374,374,375,375,375,376,376,377,377,378,378,378,379,379,380,380,380,381,381,382,382,383,383,383,384,384,385,385,385,386,386,387,387,388,388,388,389,389,390,390,391,391,391,392,392,393,393,394,394,394,395,395,396,396,397,397,398,398,398,399,399,400,400,401,401,402,402,402,403,403,404,404,405,405,406,406,406,407,407,408,408,409,409,410,410,411,411,411,412,412,413,413,414,414,415,415,416,416,417,417,418,418,418,419,419,420,420,421,421,422,422,423,423,424,424,425,425,426,426,427,427,428,428,428,429,429,430,430,431,431,432,432,433,433,434,434,435,435,436,436,437,437,438,438,439,439,440,440,441,441,442,442,443,443,444,444,445,445,446,446,447,447,448,449,449,450,450,451,451,452,452,453,453,454,454,455,455,456,456,457,457,458,459,459,460,460,461,461,462,462,463,463,464,464,465,466,466,467,467,468,468,469,469,470,471,471,472,472,473,473,474,474,475,476,476,477,477,478,478,479,480,480,481,481,482,483,483,484,484,485,485,486,487,487,488,488,489,490,490,491,491,492,493,493,494,494,495,496,496,497,497,498,499,499,500,501,501,502,502,503,504,504,505,506,506,507,507,508,509,509,510,511,511,512,513,513,514,514,515,516,516,517,518,518,519,520,520,521,522,522,523,524,524,525,526,526,527,528,528,529,530,531,531,532,533,533,534,535,535,536,537,538,538,539,540,540,541,542,543,543,544,545,545,546,547,548,548,549,550,551,551,552,553,554,554,555,556,557,557,558,559,560,560,561,562,563,563,564,565,566,567,567,568,569,570,571,571,572,573,574,575,575,576,577,578,579,579,580,581,582,583,584,584,585,586,587,588,589,590,590,591,592,593,594,595,596,597,597,598,599,600,601,602,603,604,605,606,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,655,656,657,658,659,660,661,662,664,665,666,667,668,669,670,672,673,674,675,676,678,679,680,681,683,684,685,686,688,689,690,691,693,694,695,696,698,699,700,702,703,704,706,707,708,710,711,713,714,715,717,718,720,721,723,724,725,727,728,730,731,733,734,736,737,739,741,742,744,745,747,748,750,752,753,755,757,758,760,762,763,765,767,769,770,772,774,776,777,779,781,783,785,787,789,790,792,794,796,798,800,802,804,806,808,810,812,815,817,819,821,823,825,828,830,832,834,837,839,841,844,846,849,851,854,856,859,861,864,866,869,872,874,877,880,883,885,888,891,894,897,900,903,906,909,913,916,919,922,926,929,932,936,940,943,947,951,954,958,962,966,970,974,978,983,987,991,996,1001,1005,1010,1015,1020,1025,1030,1036,1041,1047,1052,1058,1064,1070,1077,1083,1090,1097,1104,1112,1119,1127,1135,1144,1153,1162,1171,1181,1192,1202,1214,1226,1239,1252,1266,1281,1298,1315,1334,1355,1378,1403,1432,1464,1502,1548,1605,1681,1798,2047,
  };

  static uint32_t stateprobs_for_context1[256];
  static uint32_t stateprobs_for_context2[256];
  static uint32_t stateprobs_for_context3[256];
  static uint32_t stateprobs_for_context4[256];
  static uint32_t stateprobs_for_mm[256];
  static uint32_t stateprobs_lzp[256];
  static uint32_t stateprobs_lzp4[256];

  static constexpr uint8_t stateTable[256][4] = {
    {  1,  2, 0, 0},{  3,  5, 1, 0},{  4,  6, 0, 1},{  7, 10, 2, 0}, // 0-3
    {  8, 12, 1, 1},{  9, 13, 1, 1},{ 11, 14, 0, 2},{ 15, 19, 3, 0}, // 4-7
    { 16, 23, 2, 1},{ 17, 24, 2, 1},{ 18, 25, 2, 1},{ 20, 27, 1, 2}, // 8-11
    { 21, 28, 1, 2},{ 22, 29, 1, 2},{ 26, 30, 0, 3},{ 31, 33, 4, 0}, // 12-15
    { 32, 35, 3, 1},{ 32, 35, 3, 1},{ 32, 35, 3, 1},{ 32, 35, 3, 1}, // 16-19
    { 34, 37, 2, 2},{ 34, 37, 2, 2},{ 34, 37, 2, 2},{ 34, 37, 2, 2}, // 20-23
    { 34, 37, 2, 2},{ 34, 37, 2, 2},{ 36, 39, 1, 3},{ 36, 39, 1, 3}, // 24-27
    { 36, 39, 1, 3},{ 36, 39, 1, 3},{ 38, 40, 0, 4},{ 41, 43, 5, 0}, // 28-31
    { 42, 45, 4, 1},{ 42, 45, 4, 1},{ 44, 47, 3, 2},{ 44, 47, 3, 2}, // 32-35
    { 46, 49, 2, 3},{ 46, 49, 2, 3},{ 48, 51, 1, 4},{ 48, 51, 1, 4}, // 36-39
    { 50, 52, 0, 5},{ 53, 43, 6, 0},{ 54, 57, 5, 1},{ 54, 57, 5, 1}, // 40-43
    { 56, 59, 4, 2},{ 56, 59, 4, 2},{ 58, 61, 3, 3},{ 58, 61, 3, 3}, // 44-47
    { 60, 63, 2, 4},{ 60, 63, 2, 4},{ 62, 65, 1, 5},{ 62, 65, 1, 5}, // 48-51
    { 50, 66, 0, 6},{ 67, 55, 7, 0},{ 68, 57, 6, 1},{ 68, 57, 6, 1}, // 52-55
    { 70, 73, 5, 2},{ 70, 73, 5, 2},{ 72, 75, 4, 3},{ 72, 75, 4, 3}, // 56-59
    { 74, 77, 3, 4},{ 74, 77, 3, 4},{ 76, 79, 2, 5},{ 76, 79, 2, 5}, // 60-63
    { 62, 81, 1, 6},{ 62, 81, 1, 6},{ 64, 82, 0, 7},{ 83, 69, 8, 0}, // 64-67
    { 84, 71, 7, 1},{ 84, 71, 7, 1},{ 86, 73, 6, 2},{ 86, 73, 6, 2}, // 68-71
    { 44, 59, 5, 3},{ 44, 59, 5, 3},{ 58, 61, 4, 4},{ 58, 61, 4, 4}, // 72-75
    { 60, 49, 3, 5},{ 60, 49, 3, 5},{ 76, 89, 2, 6},{ 76, 89, 2, 6}, // 76-79
    { 78, 91, 1, 7},{ 78, 91, 1, 7},{ 80, 92, 0, 8},{ 93, 69, 9, 0}, // 80-83
    { 94, 87, 8, 1},{ 94, 87, 8, 1},{ 96, 45, 7, 2},{ 96, 45, 7, 2}, // 84-87
    { 48, 99, 2, 7},{ 48, 99, 2, 7},{ 88,101, 1, 8},{ 88,101, 1, 8}, // 88-91
    { 80,102, 0, 9},{103, 69,10, 0},{104, 87, 9, 1},{104, 87, 9, 1}, // 92-95
    {106, 57, 8, 2},{106, 57, 8, 2},{ 62,109, 2, 8},{ 62,109, 2, 8}, // 96-99
    { 88,111, 1, 9},{ 88,111, 1, 9},{ 80,112, 0,10},{113, 85,11, 0}, // 100-103
    {114, 87,10, 1},{114, 87,10, 1},{116, 57, 9, 2},{116, 57, 9, 2}, // 104-107
    { 62,119, 2, 9},{ 62,119, 2, 9},{ 88,121, 1,10},{ 88,121, 1,10}, // 108-111
    { 90,122, 0,11},{123, 85,12, 0},{124, 97,11, 1},{124, 97,11, 1}, // 112-115
    {126, 57,10, 2},{126, 57,10, 2},{ 62,129, 2,10},{ 62,129, 2,10}, // 116-119
    { 98,131, 1,11},{ 98,131, 1,11},{ 90,132, 0,12},{133, 85,13, 0}, // 120-123
    {134, 97,12, 1},{134, 97,12, 1},{136, 57,11, 2},{136, 57,11, 2}, // 124-127
    { 62,139, 2,11},{ 62,139, 2,11},{ 98,141, 1,12},{ 98,141, 1,12}, // 128-131
    { 90,142, 0,13},{143, 95,14, 0},{144, 97,13, 1},{144, 97,13, 1}, // 132-135
    { 68, 57,12, 2},{ 68, 57,12, 2},{ 62, 81, 2,12},{ 62, 81, 2,12}, // 136-139
    { 98,147, 1,13},{ 98,147, 1,13},{100,148, 0,14},{149, 95,15, 0}, // 140-143
    {150,107,14, 1},{150,107,14, 1},{108,151, 1,14},{108,151, 1,14}, // 144-147
    {100,152, 0,15},
    // contexts representing strong trend of 0s or 1s start from here
    {153, 95,16, 0},{154, 69,15, 1},{ 80,155, 1,15},{100,156, 0,16}, // 149-152
    {157, 95,17, 0},{158, 69,16, 1},{ 80,159, 1,16},{100,160, 0,17}, // 153-156
    {161, 95,18, 0},{162, 69,17, 1},{ 80,163, 1,17},{100,164, 0,18}, // 157-160
    {165, 95,19, 0},{166, 69,18, 1},{ 80,167, 1,18},{100,168, 0,19}, // 161-164
    {169, 95,20, 0},{170, 69,19, 1},{ 80,171, 1,19},{100,172, 0,20}, // 165-168
    {173, 95,21, 0},{174, 69,20, 1},{ 80,175, 1,20},{100,176, 0,21}, // 169-172
    {177, 95,22, 0},{178, 69,21, 1},{ 80,179, 1,21},{100,180, 0,22}, // 173-176
    {181, 95,23, 0},{182, 69,22, 1},{ 80,183, 1,22},{100,184, 0,23}, // 177-180
    {185, 95,24, 0},{186, 69,23, 1},{ 80,187, 1,23},{100,188, 0,24}, // 181-184
    {189, 95,25, 0},{190, 69,24, 1},{ 80,191, 1,24},{100,192, 0,25}, // 185-188
    {193, 95,26, 0},{194, 69,25, 1},{ 80,195, 1,25},{100,196, 0,26}, // 189-192
    {197, 95,27, 0},{198, 69,26, 1},{ 80,199, 1,26},{100,200, 0,27}, // 193-196
    {201, 95,28, 0},{202, 69,27, 1},{ 80,203, 1,27},{100,204, 0,28}, // 197-200
    {205, 95,29, 0},{206, 69,28, 1},{ 80,207, 1,28},{100,208, 0,29}, // 201-204
    // contexts with incremental counting start from here
    {209, 95,30, 0},{210, 69,29, 1},{ 80,211, 1,29},{100,212, 0,30}, // 205-208
    {213, 95,31, 0},{214, 69,30, 1},{ 80,215, 1,30},{100,216, 0,31}, // 209-212
    {217, 95,32, 0},{218, 69,31, 1},{ 80,219, 1,31},{100,220, 0,32}, // 213-216
    {221, 95,33, 0},{222, 69,32, 1},{ 80,223, 1,32},{100,224, 0,33}, // 217-220
    {225, 95,34, 0},{226, 69,33, 1},{ 80,227, 1,33},{100,228, 0,34}, // 221-224
    {229, 95,35, 0},{230, 69,34, 1},{ 80,231, 1,34},{100,232, 0,35}, // 225-228
    {233, 95,36, 0},{234, 69,35, 1},{ 80,235, 1,35},{100,236, 0,36}, // 229-232
    {237, 95,37, 0},{238, 69,36, 1},{ 80,239, 1,36},{100,240, 0,37}, // 233-236
    {241, 95,38, 0},{242, 69,37, 1},{ 80,243, 1,37},{100,244, 0,38}, // 237-240
    {245, 95,39, 0},{246, 69,38, 1},{ 80,247, 1,38},{100,248, 0,39}, // 241-244
    {249, 95,40, 0},{250, 69,39, 1},{ 80,251, 1,39},{100,252, 0,40}, // 245-248
    {249, 95,41, 0},{250, 69,40, 1},{ 80,251, 1,40},{100,252, 0,41}, // 249-252
    {1,2, 0,0},{1,2, 0,0},{1,2, 0,0} // 253-255 are unused (and in case we reach such a state we'll need to restart)
  };
  ALWAYS_INLINE static uint8_t next(uint8_t const state, const int y) {
#ifdef PRINT_TABLE_SATS
    statecounter0[state] += 1 - y;
    statecounter1[state] += y;
#endif
    return stateTable[state][y];
  }


//////////////////////////// Mixer /////////////////////////////

#define MI 5

  static short mxr_tx[MI]{};		// MI inputs

  //too slow
  ALWAYS_INLINE
  short clipx(int x) {
    if (x < -32768)
      x = -32768;
    else if (x > 32767)
      x = 32767;
    return (short)x;
  }

  ALWAYS_INLINE
  short clip(int x) {
    return (short)x;
  }

ALWAYS_INLINE void train(short *w, int err) {
    short *t = mxr_tx;
    
    w[0] = clip(w[0] + (t[0] * err + 0x8000 >> 16));
    w[1] = clip(w[1] + (t[1] * err + 0x8000 >> 16));
    w[2] = clip(w[2] + (t[2] * err + 0x8000 >> 16));
    w[3] = clip(w[3] + (t[3] * err + 0x8000 >> 16));
    w[4] = clip(w[4] + (t[4] * err + 0x8000 >> 16));
}
ALWAYS_INLINE int dot_product(short *w) {
    short *t = mxr_tx;

    int sum = t[0] * w[0];
    sum += t[1] * w[1];
    sum += t[2] * w[2];
    sum += t[3] * w[3];
    sum += t[4] * w[4];
    sum >>= 8;
    sum *= 120;
    sum >>= 13;
    return sum;
}


class Mixer {
  const int MC;	   // max contexts
  short* wx;       // MI*MC weights
  int cxt;         // context
  int pr;          // last result (scaled 12 bits)
public:
  Mixer(int m);
  ~Mixer();

  // Adjust weights to minimize coding cost of last prediction
  ALWAYS_INLINE void update(int y) {
    int err = ((y << 12) - pr) * 7;
    assert(err >= -32768 && err < 32768);
    train(&wx[cxt * MI], err);
  }

  // Input x (call up to MI times)


  // Set a context
  void set(int cx) {
    assert(cx >= 0 && cx < MC);
    cxt = cx;
  }

  // predict next bit
  int p() {
    int dp = dot_product(&wx[cxt * MI]);
    if (dp > 2047) dp = 2047;
    if (dp < -2047) dp = -2047;
    return pr = squash(dp);
  }
};

Mixer::Mixer(int m):	MC(m), cxt(0), pr(2048) {
  assert(MC>0);
  alloc(wx, MI*MC);
}

Mixer::~Mixer() {
  _aligned_free(wx);
}


//////////////////////////// Globals ////////////////////////////

static int bcount = 0;  // bit count
static int c0 = 1;  // last 0-7 bits with leading 1
static uint64_t c8 = 0;  // last 8 bytes
uint64_t tokenHash{};
uint8_t tokentype{};
uint8_t tokenlen{};

//////////////////////////// MatchModel ////////////////////////

struct mmStruct {
  int matchPos;
  uint16_t checkSum;
  uint8_t state;
  uint8_t unused;
};

class MatchModel {
  static const int MAXLEN = 120;   // maximum match length
  static const int SMCOUNT = 1 + (MAXLEN - 1) * 2 + 1;
  uint8_t* buf; // input buffer
  mmStruct* ht; // context hash -> next byte in buf, state and checksum
  int match{};  // pointer to current byte in matched context in buf
  int pos{};    // number of bytes in buf
public:
  int len{};    // length of match
  uint8_t* bytectxptr{};
  uint8_t* statePtr{};
  uint8_t expectedByte{};
private:
  uint8_t sm[(SMCOUNT + 1) << 8]{};  // len, bit, last byte -> prediction
  int mmcxt = 0;
  uint8_t* smContinuation;
public:
  static const int hashBits = 23; // hashtable (2 million 3-byte pointers to the buffer)
  static const int hashMask = (1 << hashBits) - 1; //hashtable - last hash table index
  static const int bufMask = (1 << 25) - 1; //ringbuffer (byte history)
  MatchModel();
  ~MatchModel();
  void setMatchContext();
  int getLengthAddP();
  bool isMatch(uint8_t actualbyte) const;
  int getP();
  void updateState(uint8_t c);
  void updateStateOuter();
  void updateMatchContext();
  void update(int y);
};

MatchModel::MatchModel() {
  alloc(buf, bufMask + 1 + 8); buf += 8;
  alloc(ht, hashMask + 1);
  alloc(smContinuation, 65536);
  bytectxptr = &smContinuation[0];
}

MatchModel::~MatchModel() {
  _aligned_free(buf - 8);
  _aligned_free(ht);
  _aligned_free(smContinuation);
}

void MatchModel::setMatchContext() {

  uint64_t ha = hash(c8 & 0xffffffffffff);
  const uint64_t c8hash = finalize64(ha, hashBits); //order 6
  uint16_t expectedChksum = checksum16(ha, hashBits);
  uint16_t* chksumPtr = &ht[c8hash].checkSum;
  buf[pos++] = c8;
  pos &= bufMask;

  // find or extend match
  if (len > 0) {
    ++match;
    match &= bufMask;
    if (len < MAXLEN) ++len;
  }
  else {
    if (*chksumPtr == expectedChksum) {
      match = ht[c8hash].matchPos;
      if (*(uint32_t*)&buf[match - 4] == *(uint32_t*)&buf[pos - 4])
        len++;
    }
  }

  // update index, checksum and state
  ht[c8hash].matchPos = pos;
  *chksumPtr = expectedChksum;
  statePtr = len > 0 ? &ht[c8hash].state : nullptr;
}

void MatchModel::update(int y) {
  fastbit_update(&stateprobs_for_mm[sm[mmcxt]], y);
  sm[mmcxt] = next(sm[mmcxt], y); //order2 (len+expectedchar) when matched, order 0 when not matched
}

int MatchModel::getLengthAddP() {
  // predict
  mmcxt = c0;
  if (len > 0) {
    const uint8_t expectedChar = buf[match];
    if (((expectedChar + 256) >> (8 - bcount)) == mmcxt) {
      int b = (expectedChar >> (7 - bcount)) & 1;  // next bit
      mmcxt = 1 + (len - 1) * 2 + b; //1..32
      mmcxt = mmcxt << 8 | expectedChar; // ~5+8=13 bits
    }
    else
      len = 0;
  }
  int p = fastbit_getP(&stateprobs_for_mm[sm[mmcxt]]);
  mxr_tx[0] = p_to_stretched[p]; //order2 (len+expectedchar) when matched, order 0 when not matched
  return len;
}

ALWAYS_INLINE bool MatchModel::isMatch(uint8_t actualbyte) const {
  return expectedByte == actualbyte;
}

ALWAYS_INLINE int MatchModel::getP() {
  //predict
  expectedByte = buf[match];
  size_t bytectx = (c8 & 0xff) << 8 | expectedByte;
  bytectxptr = &smContinuation[bytectx];

  int p1 = fastbit_getP(&stateprobs_lzp[*bytectxptr]);
  int p2 = fastbit_getP(&stateprobs_lzp4[*statePtr]);
  return (p1 + p2 * 7 + 4) >> 3;
}

ALWAYS_INLINE void MatchModel::updateState(uint8_t c) {
  bool y = isMatch(c);
  fastbit_update(&stateprobs_lzp[*bytectxptr], y);
  *bytectxptr = next(*bytectxptr, y);
}

ALWAYS_INLINE void MatchModel::updateMatchContext() {
  c8 = c8 << 8 | expectedByte;
}

ALWAYS_INLINE void MatchModel::updateStateOuter() {
  if (statePtr != nullptr) {
    fastbit_update(&stateprobs_lzp4[*statePtr], len > 0);
    *statePtr = next(*statePtr, len > 0);
  }
}

//////////////////////////// Predictor /////////////////////////

class Predictor {
  uint8_t* t1;  // order 1 cxt -> state
  uint8_t* t2;  // order 2 cxt -> state
  uint8_t* t23;  // sparse 2-3 cxt -> state
  uint8_t* t3;  // order 3 cxt -> state
  uint8_t* cp[5];  // pointer to bit history
public:
  static const int hashBits = 29; //512 MB
  MatchModel mm{};  // predicts next bit by matching context
  Mixer m{ 256 * 4 };

  int p();  // next prediction
  void update(int y);
  void setByteContext();
  Predictor();
  ~Predictor();
};

Predictor::Predictor() {
  alloc(t1, 0x10000);
  alloc(t2, 0x1000000);
  alloc(t23, 0x1000000);
  alloc(t3, 1 << hashBits);
  cp[0] = cp[1] = cp[2] = cp[3] = cp[4] = &t2[0];
}

Predictor::~Predictor() {
  _aligned_free(t1);
  _aligned_free(t2);
  _aligned_free(t3);
  _aligned_free(t23);
}

ALWAYS_INLINE int Predictor::p() {
  // predict
  int matchLength = mm.getLengthAddP();
  size_t offset = mapc0[c0];
  const uint8_t state0 = cp[0][offset];
  const uint8_t state1 = cp[1][offset];
  const uint8_t state2 = cp[2][offset];
  const uint8_t state3 = cp[3][offset];
  const int pr0 = fastbit_getP(&stateprobs_for_context1[state0]);
  const int pr1 = fastbit_getP(&stateprobs_for_context2[state1]);
  const int pr2 = fastbit_getP(&stateprobs_for_context3[state2]);
  const int pr3 = fastbit_getP(&stateprobs_for_context4[state3]);
  mxr_tx[1] = p_to_stretched[pr0];
  mxr_tx[2] = p_to_stretched[pr1];
  mxr_tx[3] = p_to_stretched[pr2];
  mxr_tx[4] = p_to_stretched[pr3];

  matchLength = matchLength == 0 ? 0 :
    matchLength < 2 ? 1 :
    matchLength < 12 ? 2 :
    3;

  m.set(matchLength << 8 | c0); // 4 * 256 (actually only 4 * 255 states are used)
  return m.p();
}

ALWAYS_INLINE void Predictor::update(int y) {
  // update model
  assert(y==0 || y==1);
  size_t offset = mapc0[c0];
  uint8_t* state0 = &cp[0][offset];
  uint8_t* state1 = &cp[1][offset];
  uint8_t* state2 = &cp[2][offset];
  uint8_t* state3 = &cp[3][offset];
  fastbit_update(&stateprobs_for_context1[*state0], y);
  fastbit_update(&stateprobs_for_context2[*state1], y);
  fastbit_update(&stateprobs_for_context3[*state2], y);
  fastbit_update(&stateprobs_for_context4[*state3], y);

  *state0 = next(*state0, y);
  *state1 = next(*state1, y);
  *state2 = next(*state2, y);
  *state3 = next(*state3, y);

  m.update(y);
  mm.update(y);
  // update context
  c0+=c0+y;
  ++bcount;
  if (c0>=256) {
    c0-=256;
    c8 = c8 << 8 | c0;
    c0=1;
    bcount=0;
  }
}

ALWAYS_INLINE void Predictor::setByteContext() {
  
  cp[0] = t1 + (c8 & 0xff) * 256;  //order 1
  cp[1] = t2 + (c8 & 0xffff) * 256; //order 2
  cp[2] = t23 + ((c8 >> 16) & 0xffff) * 256; //sparse 2-3
  cp[3] = &t3[finalize64(hash(c8 & 0xffffff), hashBits)]; // order 3

}


class BufferedFileReaderWriter {
public:
  BufferedFileReaderWriter(FILE* inputFile, FILE* outputFile) : input(inputFile), output(outputFile) {
    alloc(buffer_in, bufferSize);
    alloc(buffer_out, bufferSize);
    buffer_in_readpos = 0;
    buffer_in_bytes = 0;
    buffer_out_bytes = 0;
  }

  ~BufferedFileReaderWriter() {
    flush();
  }

  ALWAYS_INLINE int read() {
    if (buffer_in_readpos >= buffer_in_bytes) {
      buffer_in_bytes = fread(buffer_in, 1, bufferSize, input);
      buffer_in_readpos = 0;
      if (buffer_in_bytes <= 0) {
        return EOF;
      }
    }
    return buffer_in[buffer_in_readpos++];
  }

  ALWAYS_INLINE void write(uint8_t c) {
    if (buffer_out_bytes >= bufferSize) {
      flush();
    }
    buffer_out[buffer_out_bytes++] = c;
  }

  ALWAYS_INLINE void flush() {
    if (buffer_out_bytes > 0) {
      fwrite(buffer_out, 1, buffer_out_bytes, output);
      buffer_out_bytes = 0;
    }
  }

private:
  FILE* input;
  FILE* output;
  uint8_t* buffer_in;
  uint8_t* buffer_out;
  int buffer_in_readpos;
  int buffer_in_bytes;
  int buffer_out_bytes;
  static const int bufferSize = 4096; // 4KB
};

//////////////////////////// Encoder ////////////////////////////


class Encoder {
private:
  Predictor predictor;
  BufferedFileReaderWriter *readwriter;
  uint32_t x1, x2;       // Range, initially [0, 1), scaled by 2^32
  uint32_t x;            // Decompress mode: last 4 input bytes of archive
  const uint32_t lzpMinMatchLen;
  const uint32_t lzpMinP;

  ALWAYS_INLINE
  void EncodeBit(int p, int y) {
    assert(p >= 0 && p < 4096);
    p += p < 2048;
    uint32_t xmid = x1 + (x2 - x1 >> 12) * p + ((x2 - x1 & 0xfff) * p >> 12);
    assert(xmid >= x1 && xmid < x2);
    y ? (x2 = xmid) : (x1 = xmid + 1);
    while (true) {  // pass equal leading bytes of range
      const uint32_t leading = x2 >> 24;
      if (leading != x1 >> 24)
        break;
      readwriter->write(leading);
      x1 <<= 8;
      x2 = (x2 << 8) + 255;
    }
  }

  ALWAYS_INLINE
  int DecodeBit(int p) {
    assert(p >= 0 && p < 4096);
    p += p < 2048;
    uint32_t xmid = x1 + (x2 - x1 >> 12) * p + ((x2 - x1 & 0xfff) * p >> 12);
    assert(xmid >= x1 && xmid < x2);
    int y = x <= xmid;
    y ? (x2 = xmid) : (x1 = xmid + 1);
    while (true) {  // pass equal leading bytes of range
      const uint32_t leading = x2 >> 24;
      if (leading != x1 >> 24)
        break;
      x1 <<= 8;
      x2 = (x2 << 8) + 255;
      x = (x << 8) + (readwriter->read() & 255);  // EOF is OK
    }
    return y;
  }
  
public:
  Encoder(BufferedFileReaderWriter *f, uint32_t lzpMinMatchLen, uint32_t lzpMinP);

  // Compress one byte
  void compress() {
    int c;

    while ((c = readwriter->read()) != EOF) {
      predictor.mm.setMatchContext();
      bool isMatch = false;
      bool toUseMatchModel = predictor.mm.len > lzpMinMatchLen;
      if (toUseMatchModel) {
        int p = predictor.mm.getP();
        assert(p >= 0 && p < 4096);
        if (p > lzpMinP) {
          isMatch = predictor.mm.isMatch(c);
          EncodeBit(p, isMatch);
          if (isMatch) {
            predictor.mm.updateMatchContext();
          }
          else {
            predictor.mm.len = 0;
          }
        }
      }
      if (!isMatch) {
        predictor.setByteContext();
        for (int i = 7; i >= 0; --i) {
          int p = predictor.p();
          const int y = (c >> i) & 1;
          EncodeBit(p, y);
          predictor.update(y);
        }
      }

      if (toUseMatchModel) {
        predictor.mm.updateState(c);
      }
      predictor.mm.updateStateOuter();
    }
    
    readwriter->write(x1 >> 24);  // Flush first unequal byte of range
  }

  // Decompress and return one byte
  void decompress(long size) {
    
    for (int i = 0; i < 4; ++i)
      x = (x << 8) + (readwriter->read() & 255);

    while (size-- > 0) {
      int c = 0;
      
      predictor.mm.setMatchContext();
      bool isMatch = false;
      bool toUseMatchModel = predictor.mm.len > lzpMinMatchLen;
      if (toUseMatchModel) {
        int p = predictor.mm.getP();
        assert(p >= 0 && p < 4096);
        if (p > lzpMinP) {
          isMatch = DecodeBit(p);
          if (isMatch) {
            predictor.mm.updateMatchContext();
            c = predictor.mm.expectedByte;
          }
          else {
            predictor.mm.len = 0;
          }
        }
      }
      if (!isMatch) {
        predictor.setByteContext();
        for (int i = 0; i < 8; ++i) {
          int p = predictor.p();
          int y = DecodeBit(p);
          predictor.update(y);
          c += c + y;
        }
      }

      if (toUseMatchModel) {
        predictor.mm.updateState(c);
      }
      predictor.mm.updateStateOuter();

      readwriter->write(c);
    }
  }
};

Encoder::Encoder(BufferedFileReaderWriter* f, uint32_t lzpMinMatchLen, uint32_t lzpMinP) :
  readwriter(f), x1(0), x2(0xffffffff), x(0),
  lzpMinMatchLen(lzpMinMatchLen),
  lzpMinP(lzpMinP) {

  squash_t[0] = 0;
  for (int x = -2047; x <= 2047; ++x) {
    int i = calculate_squash(x);
    squash_t[x + 2048] = i;
  }

  for (int i = 0; i < 256; i++) {
    fastbit_setP(&stateprobs_lzp[i], 2048);
    fastbit_setP(&stateprobs_lzp4[i], 2048);
    fastbit_setP(&stateprobs_for_context1[i], 2048);
    fastbit_setP(&stateprobs_for_context2[i], 2048);
    fastbit_setP(&stateprobs_for_context3[i], 2048);
    fastbit_setP(&stateprobs_for_context4[i], 2048);
    fastbit_setP(&stateprobs_for_mm[i], 2048);
  }

  //generating 'mapc0' content which serves as a bit more cache-friendly transition in c0
  for (int offset = 0; offset <= 254; offset++) {
    if (offset < 31) {
      int c0 = offset + 1;
      mapc0[c0] = offset;
    }
    else {
      int group = (offset - 31) / 7; //0..31 (32 groups)
      int offsetwithingroup = offset - 31 - group * 7; //0..6 (7 items)
      int c0 = group | 32;
      if (offsetwithingroup == 0)
        c0 = c0;
      else if (offsetwithingroup == 1)
        c0 = c0 * 2 + 0;
      else if (offsetwithingroup == 2)
        c0 = c0 * 2 + 1;
      else if (offsetwithingroup == 3)
        c0 = c0 * 4 + 0;
      else if (offsetwithingroup == 4)
        c0 = c0 * 4 + 1;
      else if (offsetwithingroup == 5)
        c0 = c0 * 4 + 2;
      else if (offsetwithingroup == 6)
        c0 = c0 * 4 + 3;
      mapc0[c0] = 31 + group * 7 + offsetwithingroup;
    }
  }
}



//////////////////////////// User Interface ////////////////////////////

int main(int argc, char** argv) {

  // Check arguments
  if (argc < 4 || (argv[1][0] != 'c' && argv[1][0] != 'd')) {
    printf(
      "lpaq2g file compressor (codename: 'wiese') by Zoltan Gotthardt\n"
      "Licensed under GPL, http://www.gnu.org/copyleft/gpl.html\n"
      "\n"
      "To compress:   lpaq2g-wiese c input output\n"
      "To decompress: lpaq2g-wiese d input output\n");
    return 1;
  }

  // Get start time
  clock_t start = clock();

  // Open input file

  FILE* inputFile = fopen(argv[2], "rb");
  FILE* outputFile = fopen(argv[3], "wb");

  if (!inputFile || !outputFile) {
    printf("Error opening files.\n");
    return 1;
  }

  //parameters optimized for gdcc2023 task 5
  int lzpMinMatchLen = 0;
  int lzpMinP = 3800;

  for (int i = 4; i < argc; i++) {
    if (strncmp(argv[i], "-lzpMinMatchLen=", 16) == 0) {
      lzpMinMatchLen = atoi(argv[i] + 16);
    }
    else if (strncmp(argv[i], "-lzpMinP=", 9) == 0) {
      lzpMinP = atoi(argv[i] + 9);
    }
  }

  printf("-lzpMinMatchLen=%d\n", lzpMinMatchLen);
  printf("-lzpMinP=%d\n", lzpMinP);

  BufferedFileReaderWriter readerWriter(inputFile, outputFile);
  Encoder e(&readerWriter, lzpMinMatchLen, lzpMinP);

  // Compress
  if (argv[1][0] == 'c') {

    // Encode header: magic header, file size
    fseek(inputFile, 0, SEEK_END);
    long size = ftell(inputFile);
    if (size < 0 || size >= 0x7FFFFFFF) quit("input file too big");
    fseek(inputFile, 0, SEEK_SET);
    readerWriter.write('g');
    readerWriter.write(23);
    readerWriter.write(size >> 24);
    readerWriter.write(size >> 16);
    readerWriter.write(size >> 8);
    readerWriter.write(size);

    // Compress
    e.compress();

#ifdef PRINT_TABLE_SATS
    for (int i = 0; i < 256; i++)
      printf("%d\t%" PRIu64 "\t%" PRIu64 "\n", i, statecounter0[i], statecounter1[i]);
#endif
  }

  // Decompress
  else {

    // Check magic header, file size

    if (readerWriter.read() != 'g' || readerWriter.read() != 23)
      quit("Not a lpaq2g-wiese file");

    uint32_t size = readerWriter.read() << 24;
    size |= readerWriter.read() << 16;
    size |= readerWriter.read() << 8;
    size |= readerWriter.read();
    if (size < 0) quit("Bad file size");

    // Decompress
    e.decompress(size);
  }

  readerWriter.flush();

  // Report result
  printf("%ld -> %ld in %1.3f sec.\n", ftell(inputFile), ftell(outputFile), double(clock() - start) / CLOCKS_PER_SEC);

  fclose(inputFile);
  fclose(outputFile);

  return 0;
}

